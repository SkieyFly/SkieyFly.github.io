{"meta":{"title":"SkieyFly's Blog","subtitle":null,"description":null,"author":"SkieyFly","url":"http://SkieyFly.github.io","root":"/"},"pages":[],"posts":[{"title":"bzoj3684 大朋友和多叉树","slug":"bzoj3684-大朋友和多叉树","date":"2019-06-14T08:57:08.000Z","updated":"2019-06-14T09:31:24.926Z","comments":true,"path":"2019/06/14/bzoj3684-大朋友和多叉树/","link":"","permalink":"http://SkieyFly.github.io/2019/06/14/bzoj3684-大朋友和多叉树/","excerpt":"题意叶子节点权值为$1$，其它节点权值为孩子权值之和。给出根节点的权值，以及一个集合$D$，问每个点孩子个数都属于$D$有几种不同的数。 $|D|&lt;n\\le 10^5$，$1\\notin D$。 思路显然$n$就是叶子个数，dp什么的不太好做，考虑答案的生成函数$F$。有： F=x+\\sum_{i\\in D}F^i(x)为什么呢？ 考虑一个$n$个叶子节点的树是怎么构成的，一个为根，枚举其孩子树，再根据几棵子树和起来的，这就是等式右边的$\\sum$，单独的$x$表示一棵空树，也就是只有一个叶子节点（不用根据子树合并）。","text":"题意叶子节点权值为$1$，其它节点权值为孩子权值之和。给出根节点的权值，以及一个集合$D$，问每个点孩子个数都属于$D$有几种不同的数。 $|D|&lt;n\\le 10^5$，$1\\notin D$。 思路显然$n$就是叶子个数，dp什么的不太好做，考虑答案的生成函数$F$。有： F=x+\\sum_{i\\in D}F^i(x)为什么呢？ 考虑一个$n$个叶子节点的树是怎么构成的，一个为根，枚举其孩子树，再根据几棵子树和起来的，这就是等式右边的$\\sum$，单独的$x$表示一棵空树，也就是只有一个叶子节点（不用根据子树合并）。 然后我们要求$[x^n]F(x)$（$n$次项系数）。 引入拉格朗日反演： 若存在$f(x),g(x)$满足$g(f(x))=x$（多项式复合逆），则： [x^n]f(x)=\\frac{1}{n}[x^{-1}]\\frac{1}{g(x)^n}当然，由于有些多项式的较低几项为$0$，普通的多项式求逆不一定存在，假设末尾有$d$个$0$，则可以把它提出来： [x^n]f(x) = \\frac{1}{n}[x^{dn-1}]\\left(\\frac{x^d}{g(x)}\\right)^n而对于这道题，令： G(x)=x-\\sum_{i\\in D}x^i就有$G(F(x))=x$。 而多项式$G$只是常数项为$0$，那么就是$d=1$，则： [x^n]F(x) = \\frac{1}{n}[x^{n-1}]\\left(\\frac{x}{G(x)}\\right)^n实际操作就是先把$G$左移，求逆，求$ln$，乘$n$后求$exp$。 坑1.开始并没有理解读入为什么直接把多项式左移了。 2.注意多项式求$ln$的时候常数项要为$1$，求$exp$的时候常数项要为$0$，据说是因为$e^0=1$才收敛。 3.注意$exp$的时候最后那个Q数组要清空，因为回到上一层的时候求Ln时求导会用到len实际长度只有ml。打算以后尝试所有都在ntt结束后清空，防止出错。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define Mod 950009857#define g 7#define MAXN 100005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n,m;int inv[MAXN];int qp(int x,int y)&#123; int tans=1; for (;y;(y&amp;1)? tans=1ll*tans*x%Mod:0,x=1ll*x*x%Mod,y&gt;&gt;=1); return tans;&#125;int lim,rev[MAXN&lt;&lt;2];void init(int len)&#123; int l=0; for (lim=1;lim&lt;len;lim&lt;&lt;=1,l++); for (int i=0;i&lt;lim;i++) rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(l-1)); &#125;void ntt(int P[])&#123; for (int i=0;i&lt;lim;i++) if (i&lt;rev[i]) swap(P[i],P[rev[i]]); for (int i=1;i&lt;lim;i&lt;&lt;=1)&#123; int tw=qp(g,(Mod-1)/(i&lt;&lt;1)); for (int j=0;j&lt;lim;j+=i&lt;&lt;1) for (int k=0,t=1;k&lt;i;k++,t=1ll*t*tw%Mod)&#123; int a=P[j+k],b=1ll*P[j+i+k]*t%Mod; P[j+k]=(a+b)%Mod,P[j+i+k]=(a-b+Mod)%Mod; &#125; &#125;&#125;int T[MAXN&lt;&lt;2];void Inv(int P[],int Q[],int len)&#123; if (len==1)&#123; Q[0]=qp(P[0],Mod-2); return; &#125; int ml=(len+1)&gt;&gt;1; Inv(P,Q,ml); init(2*len-1); memset(Q+ml,0,sizeof(int)*(lim-ml)); memcpy(T,P,sizeof(int)*len);memset(T+len,0,sizeof(int)*(lim-len)); ntt(Q);ntt(T); for (int i=0;i&lt;lim;i++) Q[i]=1ll*Q[i]*(2-1ll*Q[i]*T[i]%Mod+Mod)%Mod; ntt(Q);reverse(Q+1,Q+lim); for (int i=0,inv=qp(lim,Mod-2);i&lt;len;i++) Q[i]=1ll*Q[i]*inv%Mod;&#125;void Der(int P[],int Q[],int len)&#123; for (int i=0;i&lt;len-1;i++) Q[i]=1ll*P[i+1]*(i+1)%Mod;&#125;void Int(int P[],int Q[],int len)&#123; for (int i=0;i&lt;len;i++) Q[i+1]=1ll*P[i]*inv[i+1]%Mod; Q[0]=0;&#125;int T1[MAXN&lt;&lt;2],T2[MAXN&lt;&lt;2];void Ln(int P[],int Q[],int len)&#123; Der(P,T1,len); Inv(P,T2,len); init(len*2-2); memset(T1+len-1,0,sizeof(int)*(lim-len+1)); memset(T2+len,0,sizeof(int)*(lim-len)); ntt(T1);ntt(T2); for (int i=0;i&lt;lim;i++) T1[i]=1ll*T1[i]*T2[i]%Mod; ntt(T1);reverse(T1+1,T1+lim); for (int i=0,inv=qp(lim,Mod-2);i&lt;len;i++) T1[i]=1ll*T1[i]*inv%Mod; Int(T1,Q,len-1); &#125;int TT[MAXN&lt;&lt;2];void Exp(int P[],int Q[],int len)&#123; if (len==1)&#123; Q[0]=1; return; &#125; int ml=(len+1)&gt;&gt;1; Exp(P,Q,ml); Ln(Q,TT,len); init(len+ml-1); for (int i=0;i&lt;len;i++) TT[i]=(P[i]-TT[i]+Mod)%Mod; TT[0]=(TT[0]+1)%Mod; memset(Q+ml,0,sizeof(int)*(lim-ml));memset(TT+len,0,sizeof(int)*(lim-len)); ntt(Q);ntt(TT); for (int i=0;i&lt;lim;i++) Q[i]=1ll*Q[i]*TT[i]%Mod; ntt(Q);reverse(Q+1,Q+lim); for (int i=0,inv=qp(lim,Mod-2);i&lt;len;i++) Q[i]=1ll*Q[i]*inv%Mod; memset(Q+len,0,sizeof(int)*(lim-len)); /* 这里很重要，Q超过len的要清空。 之前不清空是因为不会出问题（根本不会调用到）。 但是Ln里面求导的时候其实每次原函数的有效长度只有ml，而 访问到len就会出事情。 所以每次ntt以后把Q数组超出有效长度的部分清空。 */&#125;int G[MAXN&lt;&lt;2],GI[MAXN&lt;&lt;2];int GL[MAXN&lt;&lt;2];int F[MAXN&lt;&lt;2];int main()&#123; n=Read();m=Read(); for (int i=1;i&lt;=m;i++) G[Read()-1]=Mod-1; G[0]=1; //读进来就移好 inv[0]=inv[1]=1; for (int i=2;i&lt;=n;i++) inv[i]=(Mod-1ll*(Mod/i)*inv[Mod%i]%Mod)%Mod; Inv(G,GI,n); Ln(GI,GL,n); for (int i=0;i&lt;n;i++) GL[i]=1ll*GL[i]*n%Mod; GL[0]=0; Exp(GL,F,n); Write(1ll*qp(n,Mod-2)*F[n-1]%Mod);ek(); return 0;&#125;","categories":[],"tags":[]},{"title":"cf547D Mike and Fish","slug":"cf547D-Mike-and-Fish","date":"2019-06-12T06:33:08.000Z","updated":"2019-06-12T06:57:21.577Z","comments":true,"path":"2019/06/12/cf547D-Mike-and-Fish/","link":"","permalink":"http://SkieyFly.github.io/2019/06/12/cf547D-Mike-and-Fish/","excerpt":"题意坐标系上有$n$个点，要求红蓝染色，使每一行每一列红的和蓝的相差不超过$1$。 $n\\le 2\\times 10^5$，$1\\le x_i,y_i\\le 2\\times 10^5$。 思路根据套路，每个点就是一个二分图的连边。 假设题目是要求红蓝都相等，考虑这是在干嘛。 对于连结$u$的所有边，对其定向，如果是入边染红，出边染蓝。那么要求所有点红蓝数量相同，也就是入度等于出度——欧拉回路。","text":"题意坐标系上有$n$个点，要求红蓝染色，使每一行每一列红的和蓝的相差不超过$1$。 $n\\le 2\\times 10^5$，$1\\le x_i,y_i\\le 2\\times 10^5$。 思路根据套路，每个点就是一个二分图的连边。 假设题目是要求红蓝都相等，考虑这是在干嘛。 对于连结$u$的所有边，对其定向，如果是入边染红，出边染蓝。那么要求所有点红蓝数量相同，也就是入度等于出度——欧拉回路。 也就是说我们跑一遍欧拉回路，就是在定向，也就是确定了每个点是红是蓝。 再考虑至多相差$1$，就是欧拉回路在有奇点的情况下无解，所以可以加边再跑，最后不用管新加的边。 连边就把奇点两两配对（由于度数和$=2e$，所以奇点也是偶数个）。 坑1.图依旧可能不连通 2.跑欧拉回路一旦遍历完要马上删掉，不然复杂度是错的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define MAX 400005#define Lim 400000//注意点数 using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(LL x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n;int deg[MAX];int odd[MAX];int edgenum,Edge[MAX&lt;&lt;1],head[MAX],nxt[MAX&lt;&lt;1];void addedge(int x,int y)&#123; Edge[++edgenum]=y; nxt[edgenum]=head[x]; head[x]=edgenum;&#125;bool vis[MAX],ans[MAX];inline int id(int x)&#123; return (x+1)/2;&#125;void Euler(int now)&#123; for (int i=head[now];i;i=head[now])&#123; head[now]=nxt[i]; //在这里删，不能在递归后再删 if (vis[id(i)]) continue; vis[id(i)]=1; Euler(Edge[i]); ans[id(i)]=i&amp;1; &#125;&#125;int main()&#123; n=Read(); for (int i=1;i&lt;=n;i++)&#123; int x=Read(),y=Read(); addedge(x,y+Lim/2);addedge(y+Lim/2,x); deg[x]++;deg[y+Lim/2]++; &#125; int cnt=0; for (int i=1;i&lt;=Lim;i++) if (deg[i]&amp;1) odd[++cnt]=i; for (int i=1;i&lt;=cnt/2;i++) addedge(odd[i*2-1],odd[i*2]),addedge(odd[i*2],odd[i*2-1]); for (int i=1;i&lt;=Lim;i++) Euler(i); //图可能不连通 for (int i=1;i&lt;=n;i++) putchar((ans[i])? 'r':'b'); ek(); return 0;&#125;","categories":[],"tags":[]},{"title":"cf843D Dynamic Shortest Path","slug":"cf843D-Dynamic-Shortest-Path","date":"2019-06-10T08:39:02.000Z","updated":"2019-06-10T09:22:00.319Z","comments":true,"path":"2019/06/10/cf843D-Dynamic-Shortest-Path/","link":"","permalink":"http://SkieyFly.github.io/2019/06/10/cf843D-Dynamic-Shortest-Path/","excerpt":"题意给定一张$n$点$m$边的有向带非负权图，共$q$个操作，支持以下两种： 问$1$到$v$的最短路。 对于一些边边权$+1$。 $n,m\\le 10^5$，$q\\le 2000$。 思路每次跑dijkstra肯定不行。 有一种$O(m+w)$的最短路跑法，$w$是最短路长度。就是dijkstra的时候开个桶（vector）存放每种距离的点进行转移。 由于这题修改边权只会$+1$，所以改变量并不是很大，因此考虑如何将上述算法加入。","text":"题意给定一张$n$点$m$边的有向带非负权图，共$q$个操作，支持以下两种： 问$1$到$v$的最短路。 对于一些边边权$+1$。 $n,m\\le 10^5$，$q\\le 2000$。 思路每次跑dijkstra肯定不行。 有一种$O(m+w)$的最短路跑法，$w$是最短路长度。就是dijkstra的时候开个桶（vector）存放每种距离的点进行转移。 由于这题修改边权只会$+1$，所以改变量并不是很大，因此考虑如何将上述算法加入。 对于一个有负权的图dijkstra是跑不了的，所以有一种方法是改变边权： w(u,v)\\rightarrow w(u,v)+h(u)-h(v)这种改法最后会使得： dis(u,v)\\rightarrow dis(u,v)+h(u)-h(v)因此不影响最短路。 那么就要如何给点加权，其实点权就是源点到该点的最短路，因为最短路的三角不等式： dis(v)\\le dis(u)+w(u,v)所以可以先用别的最短路求一遍，然后边权就非负了，就能用dijkstra跑任意两点的最短路了。 然后这道题是用了还有一个好处，改完边权后，每个点到源点的最短路就是$0$。 因此此题修改边权的时候，最后的最短路也不会超过$n$，就可以用$O(m+w)$的那个算法啦。每次用完后再改边权即可。 时间复杂度$O(n\\log n+qm)$。 坑无 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define MAX 100005#define INF 1e18using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(LL x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n,m,k;int edgenum,Edge[MAX],head[MAX],nxt[MAX];LL W[MAX];void addedge(int x,int y,int w)&#123; Edge[++edgenum]=y; W[edgenum]=w; nxt[edgenum]=head[x]; head[x]=edgenum;&#125;struct Node&#123; int x; LL d; Node(int xx=0,LL dd=0)&#123; x=xx;d=dd; &#125; friend bool operator &lt; (Node x,Node y)&#123; return x.d&gt;y.d; &#125;&#125;;priority_queue&lt;Node&gt; q;LL Dis[MAX];bool vis[MAX];void Dij()&#123; for (int i=1;i&lt;=n;i++) Dis[i]=INF; q.push(Node(1,Dis[1]=0)); while (!q.empty())&#123; Node x=q.top();q.pop(); if (vis[x.x]) continue; vis[x.x]=1; for (int i=head[x.x];i;i=nxt[i])&#123; int tmp=Edge[i]; if (x.d+W[i]&lt;Dis[tmp])&#123; Dis[tmp]=x.d+W[i]; q.push(Node(tmp,Dis[tmp])); &#125; &#125; &#125;&#125;LL dis[MAX];vector&lt;int&gt; buck[MAX];void dij(int lim)&#123; for (int i=1;i&lt;=n;i++) dis[i]=INF,vis[i]=0; int now; buck[dis[1]=now=0].push_back(1); while (now&lt;=lim)&#123; if (!buck[now].size())&#123; now++; continue; &#125; int x=buck[now].back();buck[now].pop_back(); if (vis[x]) continue; vis[x]=1; for (int i=head[x];i;i=nxt[i])&#123; int tmp=Edge[i]; if (now+W[i]&lt;dis[tmp])&#123; dis[tmp]=now+W[i]; if (dis[tmp]&lt;=lim) buck[dis[tmp]].push_back(tmp); &#125; &#125; &#125; for (int i=1;i&lt;=n;i++) for (int j=head[i];j;j=nxt[j]) W[j]=W[j]+dis[i]-dis[Edge[j]]; //每次改边权 for (int i=1;i&lt;=n;i++) Dis[i]=min(Dis[i]+dis[i],(LL)INF);&#125;int main()&#123; n=Read(),m=Read(),k=Read(); for (int i=1;i&lt;=m;i++)&#123; int x=Read(),y=Read(),w=Read(); addedge(x,y,w); &#125; Dij(); //先跑一遍Dij for (int i=1;i&lt;=n;i++) for (int j=head[i];j;j=nxt[j]) W[j]=W[j]+Dis[i]-Dis[Edge[j]]; while (k--)&#123; int op=Read(); if (op==1)&#123; int x=Read(); Write((Dis[x]&gt;=INF)? -1:Dis[x]);ek(); &#125; else&#123; int c=Read(); for (int i=1;i&lt;=c;i++) W[Read()]++; dij(c); &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"luogu1954 [NOI2010]航空管制","slug":"luogu1954-NOI2010-航空管制","date":"2019-06-09T14:04:17.000Z","updated":"2019-06-09T14:12:06.778Z","comments":true,"path":"2019/06/09/luogu1954-NOI2010-航空管制/","link":"","permalink":"http://SkieyFly.github.io/2019/06/09/luogu1954-NOI2010-航空管制/","excerpt":"题意给定$n$个飞机起飞的最晚序号以及$m$个$a$要在$b$前飞的限制，给出一可行次序（保证有解）以及每个飞机最早起飞的序号（每个时刻只能飞一个）。 $n\\le 2000$，$m\\le 10^4$。 思路有一个套路，求最前的拓扑序比较难，所以建反图，求每个点最晚在什么时候拓扑到。 这就很方便了。 对于每个点求最晚，弹的时候，如果除它以外别的还能弹就弹（队列用优先队列，按照反过来后最早时间排，贪心思路）。","text":"题意给定$n$个飞机起飞的最晚序号以及$m$个$a$要在$b$前飞的限制，给出一可行次序（保证有解）以及每个飞机最早起飞的序号（每个时刻只能飞一个）。 $n\\le 2000$，$m\\le 10^4$。 思路有一个套路，求最前的拓扑序比较难，所以建反图，求每个点最晚在什么时候拓扑到。 这就很方便了。 对于每个点求最晚，弹的时候，如果除它以外别的还能弹就弹（队列用优先队列，按照反过来后最早时间排，贪心思路）。 坑1.luogu貌似有点卡常，开了O2能过，不开过不了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define MAX 10005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n,m;int edgenum,Edge[MAX&lt;&lt;1],head[MAX],nxt[MAX&lt;&lt;1];void addedge(int x,int y)&#123; Edge[++edgenum]=y; nxt[edgenum]=head[x]; head[x]=edgenum;&#125;int ddl[MAX];int cdeg[MAX],deg[MAX];int ans[MAX];struct Node&#123; int x,ddl; Node(int xx=0,int dd=0)&#123; x=xx;ddl=dd; &#125; friend bool operator &lt; (Node x,Node y)&#123; return x.ddl&gt;y.ddl; &#125;&#125;;priority_queue&lt;Node&gt; q;int ord[MAX];void Sol()&#123; for (int i=1;i&lt;=n;i++) deg[i]=cdeg[i]; while (!q.empty()) q.pop(); for (int i=1;i&lt;=n;i++) if (!deg[i]) q.push(Node(i,ddl[i])); int t=0; while (!q.empty())&#123; Node x=q.top();q.pop(); ord[++t]=x.x; for (int i=head[x.x];i;i=nxt[i])&#123; int tmp=Edge[i]; if (!--deg[tmp]) q.push(Node(tmp,ddl[tmp])); &#125; &#125; for (int i=n;i;i--) Write(ord[i]),(i==1)? ek():sk();&#125;void work(int s)&#123; for (int i=1;i&lt;=n;i++) deg[i]=cdeg[i]; while (!q.empty()) q.pop(); for (int i=1;i&lt;=n;i++) if (!deg[i]) q.push(Node(i,ddl[i])); int t=0; while (!q.empty())&#123; Node x=q.top();q.pop(); if (x.x==s) continue; //先不弹 if (x.ddl&gt;t+1)&#123; ans[s]=n-t; return; &#125; //如果实在没办法，别的点太早弹了，那只能弹s t++; for (int i=head[x.x];i;i=nxt[i])&#123; int tmp=Edge[i]; if (!--deg[tmp]) q.push(Node(tmp,ddl[tmp])); &#125; &#125; ans[s]=n-t; //或者不弹s就没点，队列就空了 &#125;int main()&#123; n=Read(),m=Read(); for (int i=1;i&lt;=n;i++) ddl[i]=n-Read()+1; for (int i=1;i&lt;=m;i++)&#123; int x=Read(),y=Read(); addedge(y,x);cdeg[x]++; &#125; //反转 Sol(); for (int i=1;i&lt;=n;i++) work(i); for (int i=1;i&lt;=n;i++) Write(ans[i]),(i==n)? ek():sk(); return 0;&#125;","categories":[],"tags":[]},{"title":"hdu5215 Cycle","slug":"hdu5215-Cycle","date":"2019-06-09T13:56:38.000Z","updated":"2019-06-09T14:12:40.240Z","comments":true,"path":"2019/06/09/hdu5215-Cycle/","link":"","permalink":"http://SkieyFly.github.io/2019/06/09/hdu5215-Cycle/","excerpt":"题意给定一张$n$点$m$边的无向图，问是否存在奇环和偶环。 $n\\le 10^5$，$m\\le 3\\times 10^5$，$T\\le 30$。 思路是否有奇环就判是不是二分图（没有奇环肯定可以黑白染色，不能黑白染色就有奇环）。 对于偶环，仍旧考虑dfs树和非树边，如果找到偶环就找到了，否则看奇环是否有交（这题中注意环可以经过重复点，所以是点覆盖不是边），有交的话，把公共部分去掉就是偶环了。","text":"题意给定一张$n$点$m$边的无向图，问是否存在奇环和偶环。 $n\\le 10^5$，$m\\le 3\\times 10^5$，$T\\le 30$。 思路是否有奇环就判是不是二分图（没有奇环肯定可以黑白染色，不能黑白染色就有奇环）。 对于偶环，仍旧考虑dfs树和非树边，如果找到偶环就找到了，否则看奇环是否有交（这题中注意环可以经过重复点，所以是点覆盖不是边），有交的话，把公共部分去掉就是偶环了。 坑1.注意是点覆盖不是边覆盖。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define MAX 300005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n,m;int edgenum,Edge[MAX&lt;&lt;1],head[MAX],nxt[MAX&lt;&lt;1];void addedge(int x,int y)&#123; Edge[++edgenum]=y; nxt[edgenum]=head[x]; head[x]=edgenum;&#125;namespace odd&#123; int col[MAX]; bool flag; void dfs(int now,int fa)&#123; if (flag) return; for (int i=head[now];i;i=nxt[i])&#123; if (flag) return; int tmp=Edge[i]; if (tmp==fa) continue; if (~col[tmp])&#123; if (col[tmp]==col[now])&#123; flag=1; return; &#125; &#125; else&#123; col[tmp]=col[now]^1; dfs(tmp,now); &#125; &#125; &#125; void work()&#123; memset(col,-1,sizeof(col)); flag=0; for (int i=1;i&lt;=n;i++) if (col[i]==-1)&#123; dfs(i,col[i]=0); if (flag)&#123; puts(\"YES\"); return; &#125; &#125; puts(\"NO\"); &#125;&#125;namespace even&#123; bool flag; bool vis[MAX&lt;&lt;1]; bool cover[MAX]; int father[MAX],dep[MAX]; inline int anti(int x)&#123; return ((x-1)^1)+1; &#125; void dfs(int now,int fa)&#123; if (flag) return; dep[now]=dep[fa]+1;father[now]=fa; for (int i=head[now];i;i=nxt[i])&#123; if (flag) return; if (vis[i]) continue; vis[i]=vis[anti(i)]=1; int tmp=Edge[i]; if (!dep[tmp]) dfs(tmp,now); else&#123; if ((dep[now]-dep[tmp])&amp;1)&#123; flag=1; return; &#125; int x=now; while (x!=father[tmp])&#123; //要把终点也盖了 if (cover[x])&#123; flag=1; return; &#125; cover[x]=1; x=father[x]; &#125; &#125; &#125; &#125; void work()&#123; memset(vis,0,sizeof(vis)); memset(dep,0,sizeof(dep)); memset(cover,0,sizeof(cover)); flag=0; for (int i=1;i&lt;=n;i++) if (!dep[i])&#123; dep[i]=1; dfs(i,0); if (flag)&#123; puts(\"YES\"); return; &#125; &#125; puts(\"NO\"); &#125;&#125;void solve()&#123; n=Read(),m=Read(); edgenum=0;memset(head,0,sizeof(head)); for (int i=1;i&lt;=m;i++)&#123; int x=Read(),y=Read(); addedge(x,y);addedge(y,x); &#125; odd::work(); even::work();&#125;int main()&#123; int T=Read(); while (T--) solve(); return 0;&#125;","categories":[],"tags":[]},{"title":"cf521E Cycling City","slug":"cf521E-Cycling-City","date":"2019-06-09T13:40:43.000Z","updated":"2019-06-09T13:51:59.892Z","comments":true,"path":"2019/06/09/cf521E-Cycling-City/","link":"","permalink":"http://SkieyFly.github.io/2019/06/09/cf521E-Cycling-City/","excerpt":"题意给定一张$n$点$m$边的无向图（无重边无自环），问是否有一对起点和出发点，存在三条在中途不交的简单路径，并给出方案。 $n,m\\le 2\\times 10^5$。 思路如果图是个仙人掌（不存在一条边在两个简单环中），那么不存在，否则是存在的。 因为无向图环的特殊性（一条非树边和树链构成），所以画个图，考虑两个相交的环，公共部分链的端点就可以是起点终点。那么也易知可以得到三条路径。 非树边覆盖的时候暴力覆盖是对的，因为每条边至多盖$1$次（否则就找到公共部分了）。","text":"题意给定一张$n$点$m$边的无向图（无重边无自环），问是否有一对起点和出发点，存在三条在中途不交的简单路径，并给出方案。 $n,m\\le 2\\times 10^5$。 思路如果图是个仙人掌（不存在一条边在两个简单环中），那么不存在，否则是存在的。 因为无向图环的特殊性（一条非树边和树链构成），所以画个图，考虑两个相交的环，公共部分链的端点就可以是起点终点。那么也易知可以得到三条路径。 非树边覆盖的时候暴力覆盖是对的，因为每条边至多盖$1$次（否则就找到公共部分了）。 坑1.图可能不连通，所以每个连通块都要。 2.一开始求路径没想清楚。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define MAX 200005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n,m;int edgenum,Edge[MAX&lt;&lt;1],head[MAX],nxt[MAX&lt;&lt;1];void addedge(int x,int y)&#123; Edge[++edgenum]=y; nxt[edgenum]=head[x]; head[x]=edgenum;&#125;pair&lt;int,int&gt; cover[MAX];int father[MAX],dep[MAX];vector&lt;int&gt; p[3];void addpath(int id,bool tag,int x,int y)&#123; vector&lt;int&gt; t;t.clear(); bool flag=0; if (dep[x]&lt;dep[y]) swap(x,y),flag=1; if (tag) t.push_back(x),t.push_back(y); else while (x!=father[y]) t.push_back(x),x=father[x]; if (flag) reverse(t.begin(),t.end()); for (int i=0,sz=t.size();i&lt;sz-1;i++) p[id].push_back(t[i]); //这里加路径不加最后一个点，因为后面方便 &#125;void work(int d1,int u1,int d2,int u2,int st)&#123; puts(\"YES\"); int ed=(dep[u1]&gt;dep[u2])? u1:u2; //找到交，确定路径起始点 addpath(0,0,st,ed); addpath(1,0,st,d1);addpath(1,1,d1,u1);addpath(1,0,u1,ed); addpath(2,0,st,d2);addpath(2,1,d2,u2);addpath(2,0,u2,ed); for (int i=0;i&lt;3;i++) p[i].push_back(ed); for (int i=0;i&lt;3;i++)&#123; int sz=p[i].size(); Write(sz);sk(); for (int j=0;j&lt;sz;j++) Write(p[i][j]),(j==sz-1)? ek():sk(); &#125; exit(0);&#125;bool vis[MAX&lt;&lt;1];inline int anti(int x)&#123; return ((x-1)^1)+1;&#125;void dfs(int now,int fa)&#123; dep[now]=dep[fa]+1;father[now]=fa; for (int i=head[now];i;i=nxt[i])&#123; if (vis[i]) continue; vis[i]=vis[anti(i)]=1; int tmp=Edge[i]; if (!dep[tmp]) dfs(tmp,now); else&#123; int x=now; while (x!=tmp)&#123; if (cover[x].first) work(now,tmp,cover[x].first,cover[x].second,x); cover[x]=make_pair(now,tmp); //记录非树边的起点和终点 x=father[x]; &#125; &#125; &#125;&#125;int main()&#123; n=Read(),m=Read(); for (int i=1;i&lt;=m;i++)&#123; int x=Read(),y=Read(); addedge(x,y);addedge(y,x); &#125; for (int i=1;i&lt;=n;i++) if (!dep[i])&#123; dep[i]=1; dfs(i,0); &#125; puts(\"NO\"); return 0;&#125;","categories":[],"tags":[]},{"title":"hdu6051 If the starlight never fade","slug":"hdu6051-If-the-starlight-never-fade","date":"2019-06-09T13:38:17.000Z","updated":"2019-06-10T09:21:32.577Z","comments":true,"path":"2019/06/09/hdu6051-If-the-starlight-never-fade/","link":"","permalink":"http://SkieyFly.github.io/2019/06/09/hdu6051-If-the-starlight-never-fade/","excerpt":"题意给定$n,p$，定义$f(i)$为满足$(x+y)^i\\equiv x^i\\bmod p$且$y\\le n$的$(x,y)$的数量，求： \\sum_{i=1}^{p-1}i\\times f(i)$n\\le p\\le 10^9+7$。 思路由于是质数，所以考虑用原根代换。令$x=g^a,y=g^b$，那么： (g^a+g^b)^i=g^{ai}\\Rightarrow (1+g^{b-a})^i=1令$g^k=1+g^{b-a}$，有$g^{ki}=1$，所以$ki\\equiv 0\\bmod (p-1)$，因此对于每个$i$，$k$一定是$\\frac{p-1}{\\gcd(i,p-1)}$的倍数，感性理解就是$k$至少应该包含$(p-1)$与$i$取$\\gcd$后剩下的那些因数，继而这样的$k$有$\\gcd(i-1,p-1)$个。","text":"题意给定$n,p$，定义$f(i)$为满足$(x+y)^i\\equiv x^i\\bmod p$且$y\\le n$的$(x,y)$的数量，求： \\sum_{i=1}^{p-1}i\\times f(i)$n\\le p\\le 10^9+7$。 思路由于是质数，所以考虑用原根代换。令$x=g^a,y=g^b$，那么： (g^a+g^b)^i=g^{ai}\\Rightarrow (1+g^{b-a})^i=1令$g^k=1+g^{b-a}$，有$g^{ki}=1$，所以$ki\\equiv 0\\bmod (p-1)$，因此对于每个$i$，$k$一定是$\\frac{p-1}{\\gcd(i,p-1)}$的倍数，感性理解就是$k$至少应该包含$(p-1)$与$i$取$\\gcd$后剩下的那些因数，继而这样的$k$有$\\gcd(i-1,p-1)$个。 注：这也是$x^k\\equiv 1\\bmod p$有$\\gcd(k,p-1)$个解的证明。 而容易知道$g^k=1+g^{b-a}&gt;1$，所以要$k&gt;0$，因此严格来说是$\\gcd(i,p-1)-1$个解，这样的话确定每个$k$和$y$就有一个$x$对应，所以对于一个$y$就有$\\gcd(i,p-1)-1$个$x$，因此最后就是计算： m\\times \\sum_{i=1}^{p-1}\\gcd(i,p-1)-1=m\\times \\left(\\sum_{i=1}^{p-1}\\gcd(i,p-1)-\\frac{p(p-1)}{2}\\right)重点就是$\\gcd$的求和： \\sum_{i=1}^{p-1}\\gcd(i,p-1)=\\sum_{d}d\\sum_{i,d|i}i\\times [\\gcd(i,d)=1]=\\sum d^2\\sum_{i=1}^{\\lfloor\\frac{p-1}{d}\\rfloor}i\\times \\left[\\gcd\\left(\\lfloor\\frac{p-1}{d}\\rfloor,i\\right)=1\\right]令$a=\\lfloor\\frac{p-1}{d}\\rfloor$，一个数$x$与$a$互质，则$a-x$也与$a$互质，所以： \\sum_{i=1}^{a}i\\times \\gcd(i,a)=\\frac{a\\times \\varphi(a)+[a=1]}{2}然后枚举约数即可。 坑1.算$\\varphi$的时候，由于$x$要一边除，原先prime[i]&lt;=x/prime[i]忘备份了。 2.算$\\varphi$的时候最后判的是x&gt;1而不是x&gt;0。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define Mod 1000000007#define MAXNUM 2000005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int primenum,prime[MAXNUM+50],phi[MAXNUM+50];void init()&#123; phi[1]=1; for (int i=2;i&lt;=MAXNUM;i++)&#123; if (!phi[i]) prime[++primenum]=i,phi[i]=i-1; for (int j=1;j&lt;=primenum&amp;&amp;prime[j]&lt;=MAXNUM/i;j++)&#123; if (i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;int p,_p,n,cnt;int get(int x)&#123; if (x&lt;=MAXNUM) return phi[x]; int tans=x,cx=x; for (int i=1;prime[i]&lt;=cx/prime[i];i++) if (x%prime[i]==0)&#123; while (x%prime[i]==0) x/=prime[i]; tans=tans/prime[i]*(prime[i]-1); &#125; if (x&gt;1) tans=tans/x*(x-1); return tans;&#125;void solve()&#123; n=Read(),_p=(p=Read())-1; int ans=0; for (int d=1;d&lt;=_p/d;d++) if (_p%d==0)&#123; int _d=_p/d; ans=(ans+1ll*d*d%Mod*((1ll*_d*get(_d)+(_d==1))/2%Mod)%Mod)%Mod; if (_p/d!=d) ans=(ans+1ll*_d*_d%Mod*((1ll*d*get(d)+(d==1))/2%Mod)%Mod)%Mod; &#125; ans=(1ll*n*ans%Mod-1ll*n*(1ll*p*_p/2%Mod)%Mod+Mod)%Mod; printf(\"Case #%d: %d\\n\",++cnt,ans);&#125;int main()&#123; int T=Read(); init(); while (T--) solve(); return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-06-07T08:47:57.319Z","updated":"2019-06-07T08:47:57.319Z","comments":true,"path":"2019/06/07/hello-world/","link":"","permalink":"http://SkieyFly.github.io/2019/06/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}