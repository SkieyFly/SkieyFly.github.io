{"meta":{"title":"SkieyFly's Blog","subtitle":null,"description":null,"author":"SkieyFly","url":"http://SkieyFly.github.io","root":"/"},"pages":[],"posts":[{"title":"cf521E Cycling City","slug":"cf521E-Cycling-City","date":"2019-06-09T13:40:43.000Z","updated":"2019-06-09T13:51:59.892Z","comments":true,"path":"2019/06/09/cf521E-Cycling-City/","link":"","permalink":"http://SkieyFly.github.io/2019/06/09/cf521E-Cycling-City/","excerpt":"题意给定一张$n$点$m$边的无向图（无重边无自环），问是否有一对起点和出发点，存在三条在中途不交的简单路径，并给出方案。 $n,m\\le 2\\times 10^5$。 思路如果图是个仙人掌（不存在一条边在两个简单环中），那么不存在，否则是存在的。 因为无向图环的特殊性（一条非树边和树链构成），所以画个图，考虑两个相交的环，公共部分链的端点就可以是起点终点。那么也易知可以得到三条路径。 非树边覆盖的时候暴力覆盖是对的，因为每条边至多盖$1$次（否则就找到公共部分了）。","text":"题意给定一张$n$点$m$边的无向图（无重边无自环），问是否有一对起点和出发点，存在三条在中途不交的简单路径，并给出方案。 $n,m\\le 2\\times 10^5$。 思路如果图是个仙人掌（不存在一条边在两个简单环中），那么不存在，否则是存在的。 因为无向图环的特殊性（一条非树边和树链构成），所以画个图，考虑两个相交的环，公共部分链的端点就可以是起点终点。那么也易知可以得到三条路径。 非树边覆盖的时候暴力覆盖是对的，因为每条边至多盖$1$次（否则就找到公共部分了）。 坑1.图可能不连通，所以每个连通块都要。 2.一开始求路径没想清楚。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define MAX 200005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int n,m;int edgenum,Edge[MAX&lt;&lt;1],head[MAX],nxt[MAX&lt;&lt;1];void addedge(int x,int y)&#123; Edge[++edgenum]=y; nxt[edgenum]=head[x]; head[x]=edgenum;&#125;pair&lt;int,int&gt; cover[MAX];int father[MAX],dep[MAX];vector&lt;int&gt; p[3];void addpath(int id,bool tag,int x,int y)&#123; vector&lt;int&gt; t;t.clear(); bool flag=0; if (dep[x]&lt;dep[y]) swap(x,y),flag=1; if (tag) t.push_back(x),t.push_back(y); else while (x!=father[y]) t.push_back(x),x=father[x]; if (flag) reverse(t.begin(),t.end()); for (int i=0,sz=t.size();i&lt;sz-1;i++) p[id].push_back(t[i]); //这里加路径不加最后一个点，因为后面方便 &#125;void work(int d1,int u1,int d2,int u2,int st)&#123; puts(\"YES\"); int ed=(dep[u1]&gt;dep[u2])? u1:u2; //找到交，确定路径起始点 addpath(0,0,st,ed); addpath(1,0,st,d1);addpath(1,1,d1,u1);addpath(1,0,u1,ed); addpath(2,0,st,d2);addpath(2,1,d2,u2);addpath(2,0,u2,ed); for (int i=0;i&lt;3;i++) p[i].push_back(ed); for (int i=0;i&lt;3;i++)&#123; int sz=p[i].size(); Write(sz);sk(); for (int j=0;j&lt;sz;j++) Write(p[i][j]),(j==sz-1)? ek():sk(); &#125; exit(0);&#125;bool vis[MAX&lt;&lt;1];inline int anti(int x)&#123; return ((x-1)^1)+1;&#125;void dfs(int now,int fa)&#123; dep[now]=dep[fa]+1;father[now]=fa; for (int i=head[now];i;i=nxt[i])&#123; if (vis[i]) continue; vis[i]=vis[anti(i)]=1; int tmp=Edge[i]; if (!dep[tmp]) dfs(tmp,now); else&#123; int x=now; while (x!=tmp)&#123; if (cover[x].first) work(now,tmp,cover[x].first,cover[x].second,x); cover[x]=make_pair(now,tmp); //记录非树边的起点和终点 x=father[x]; &#125; &#125; &#125;&#125;int main()&#123; n=Read(),m=Read(); for (int i=1;i&lt;=m;i++)&#123; int x=Read(),y=Read(); addedge(x,y);addedge(y,x); &#125; for (int i=1;i&lt;=n;i++) if (!dep[i])&#123; dep[i]=1; dfs(i,0); &#125; puts(\"NO\"); return 0;&#125;","categories":[],"tags":[]},{"title":"hdu6051 If the starlight never fade","slug":"hdu6051-If-the-starlight-never-fade","date":"2019-06-09T13:38:17.000Z","updated":"2019-06-09T13:40:29.714Z","comments":true,"path":"2019/06/09/hdu6051-If-the-starlight-never-fade/","link":"","permalink":"http://SkieyFly.github.io/2019/06/09/hdu6051-If-the-starlight-never-fade/","excerpt":"题意给定$n,p$，定义$f(i)$为满足$(x+y)^i\\equiv x^i\\bmod p$且$y\\le n$的$(x,y)$的数量，求： \\sum_{i=1}^{p-1}i\\times f(i)$n\\le p\\le 10^9+7$。 思路由于是质数，所以考虑用原根代换。令$x=g^a,y=g^b$，那么： (g^a+g^b)^i=g^{ai}\\Rightarrow (1+g^{b-a})^i=1令$g^k=1+g^{b-a}$，有$g^{ki}=1$，所以$ki\\equiv 0\\bmod (p-1)$，因此对于每个$i$，$k$一定是$\\frac{p-1}{\\gcd(i,p-1)}$的倍数，感性理解就是$k$至少应该包含$(p-1)$与$i$取$\\gcd$后剩下的那些因数，继而这样的$k$有$\\gcd(i-1,p-1)$个。","text":"题意给定$n,p$，定义$f(i)$为满足$(x+y)^i\\equiv x^i\\bmod p$且$y\\le n$的$(x,y)$的数量，求： \\sum_{i=1}^{p-1}i\\times f(i)$n\\le p\\le 10^9+7$。 思路由于是质数，所以考虑用原根代换。令$x=g^a,y=g^b$，那么： (g^a+g^b)^i=g^{ai}\\Rightarrow (1+g^{b-a})^i=1令$g^k=1+g^{b-a}$，有$g^{ki}=1$，所以$ki\\equiv 0\\bmod (p-1)$，因此对于每个$i$，$k$一定是$\\frac{p-1}{\\gcd(i,p-1)}$的倍数，感性理解就是$k$至少应该包含$(p-1)$与$i$取$\\gcd$后剩下的那些因数，继而这样的$k$有$\\gcd(i-1,p-1)$个。 注：这也是$x^k\\equiv 1\\bmod p$有$\\gcd(k,p-1)$个解的证明。 而容易知道$g^k=1+g^{b-a}&gt;1$，所以要$k&gt;0$，因此严格来说是$\\gcd(i,p-1)-1$个解，这样的话确定每个$k$和$y$就有一个$x$对应，所以对于一个$y$就有$\\gcd(i,p-1)-1$个$x$，因此最后就是计算： m\\times \\sum_{i=1}^{p-1}\\gcd(i,p-1)-1=m\\times \\left(\\sum_{i=1}^{p-1}\\gcd(i,p-1)-\\frac{p(p-1)}{2}\\right)重点就是$\\gcd$的求和： \\sum_{i=1}^{p-1}\\gcd(i,p-1)=\\sum_{d}d\\sum_{i,d|i}i\\times [\\gcd(i,d)=1]=\\sum d^2\\sum_{i=1}^{\\lfloor\\frac{p-1}{d}\\rfloor}i\\times \\left[\\gcd\\left(\\lfloor\\frac{p-1}{d}\\rfloor,i\\right)=1\\right]令$a=\\lfloor\\frac{p-1}{d}\\rfloor$，一个数$x$与$a$互质，则$a-x$也与$a$互质，所以： \\sum_{i=1}^{a}i\\times \\gcd(i,a)=\\frac{a\\times \\varphi(a)+[a=1]}{2}然后枚举约数即可。 坑1.算$\\varphi$的时候，由于$x$要一边除，原先prime[i]&lt;=x/prime[i]忘备份了。 2.算$\\varphi$的时候最后判的是x&gt;1而不是x&gt;0。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define LL long long#define sk() (putchar(' '))#define ek() (putchar('\\n'))#define Mod 1000000007#define MAXNUM 2000005using namespace std;int Read()&#123; int x=0,flag=1;char ch=0; while (ch&lt;'0'||ch&gt;'9')&#123; if (ch=='-') flag=-1; ch=getchar(); &#125; while (ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48; ch=getchar(); &#125; return x*flag;&#125;void Write(int x)&#123; if (x&lt;0) x=-x,putchar('-'); if (x&gt;9) Write(x/10); putchar(x%10+48);&#125;int primenum,prime[MAXNUM+50],phi[MAXNUM+50];void init()&#123; phi[1]=1; for (int i=2;i&lt;=MAXNUM;i++)&#123; if (!phi[i]) prime[++primenum]=i,phi[i]=i-1; for (int j=1;j&lt;=primenum&amp;&amp;prime[j]&lt;=MAXNUM/i;j++)&#123; if (i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;int p,_p,n,cnt;int get(int x)&#123; if (x&lt;=MAXNUM) return phi[x]; int tans=x,cx=x; for (int i=1;prime[i]&lt;=cx/prime[i];i++) if (x%prime[i]==0)&#123; while (x%prime[i]==0) x/=prime[i]; tans=tans/prime[i]*(prime[i]-1); &#125; if (x&gt;1) tans=tans/x*(x-1); return tans;&#125;void solve()&#123; n=Read(),_p=(p=Read())-1; int ans=0; for (int d=1;d&lt;=_p/d;d++) if (_p%d==0)&#123; int _d=_p/d; ans=(ans+1ll*d*d%Mod*((1ll*_d*get(_d)+(_d==1))/2%Mod)%Mod)%Mod; if (_p/d!=d) ans=(ans+1ll*_d*_d%Mod*((1ll*d*get(d)+(d==1))/2%Mod)%Mod)%Mod; &#125; ans=(1ll*n*ans%Mod-1ll*n*(1ll*p*_p/2%Mod)%Mod+Mod)%Mod; printf(\"Case #%d: %d\\n\",++cnt,ans);&#125;int main()&#123; int T=Read(); init(); while (T--) solve(); return 0;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-06-07T08:47:57.319Z","updated":"2019-06-07T08:47:57.319Z","comments":true,"path":"2019/06/07/hello-world/","link":"","permalink":"http://SkieyFly.github.io/2019/06/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}